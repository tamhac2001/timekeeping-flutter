// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'absent_form_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AbsentFormEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAbsentFormList,
    required TResult Function(DateTime? startDate) startDatePicked,
    required TResult Function(DateTime? endDate) endDatePicked,
    required TResult Function(Reason reason) reasonChanged,
    required TResult Function(String noteChanged) noteChanged,
    required TResult Function() formSubmitted,
    required TResult Function() cancelled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAbsentFormList value) getAbsentFormList,
    required TResult Function(_StartDatePicked value) startDatePicked,
    required TResult Function(_EndDatePicked value) endDatePicked,
    required TResult Function(_ReasonChanged value) reasonChanged,
    required TResult Function(_NoteChanged value) noteChanged,
    required TResult Function(_FormSubmitted value) formSubmitted,
    required TResult Function(_Cancelled value) cancelled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AbsentFormEventCopyWith<$Res> {
  factory $AbsentFormEventCopyWith(
          AbsentFormEvent value, $Res Function(AbsentFormEvent) then) =
      _$AbsentFormEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$AbsentFormEventCopyWithImpl<$Res>
    implements $AbsentFormEventCopyWith<$Res> {
  _$AbsentFormEventCopyWithImpl(this._value, this._then);

  final AbsentFormEvent _value;
  // ignore: unused_field
  final $Res Function(AbsentFormEvent) _then;
}

/// @nodoc
abstract class _$$_GetAbsentFormListCopyWith<$Res> {
  factory _$$_GetAbsentFormListCopyWith(_$_GetAbsentFormList value,
          $Res Function(_$_GetAbsentFormList) then) =
      __$$_GetAbsentFormListCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GetAbsentFormListCopyWithImpl<$Res>
    extends _$AbsentFormEventCopyWithImpl<$Res>
    implements _$$_GetAbsentFormListCopyWith<$Res> {
  __$$_GetAbsentFormListCopyWithImpl(
      _$_GetAbsentFormList _value, $Res Function(_$_GetAbsentFormList) _then)
      : super(_value, (v) => _then(v as _$_GetAbsentFormList));

  @override
  _$_GetAbsentFormList get _value => super._value as _$_GetAbsentFormList;
}

/// @nodoc

class _$_GetAbsentFormList
    with DiagnosticableTreeMixin
    implements _GetAbsentFormList {
  const _$_GetAbsentFormList();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsentFormEvent.getAbsentFormList()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'AbsentFormEvent.getAbsentFormList'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_GetAbsentFormList);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAbsentFormList,
    required TResult Function(DateTime? startDate) startDatePicked,
    required TResult Function(DateTime? endDate) endDatePicked,
    required TResult Function(Reason reason) reasonChanged,
    required TResult Function(String noteChanged) noteChanged,
    required TResult Function() formSubmitted,
    required TResult Function() cancelled,
  }) {
    return getAbsentFormList();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
  }) {
    return getAbsentFormList?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
    required TResult orElse(),
  }) {
    if (getAbsentFormList != null) {
      return getAbsentFormList();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAbsentFormList value) getAbsentFormList,
    required TResult Function(_StartDatePicked value) startDatePicked,
    required TResult Function(_EndDatePicked value) endDatePicked,
    required TResult Function(_ReasonChanged value) reasonChanged,
    required TResult Function(_NoteChanged value) noteChanged,
    required TResult Function(_FormSubmitted value) formSubmitted,
    required TResult Function(_Cancelled value) cancelled,
  }) {
    return getAbsentFormList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
  }) {
    return getAbsentFormList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
    required TResult orElse(),
  }) {
    if (getAbsentFormList != null) {
      return getAbsentFormList(this);
    }
    return orElse();
  }
}

abstract class _GetAbsentFormList implements AbsentFormEvent {
  const factory _GetAbsentFormList() = _$_GetAbsentFormList;
}

/// @nodoc
abstract class _$$_StartDatePickedCopyWith<$Res> {
  factory _$$_StartDatePickedCopyWith(
          _$_StartDatePicked value, $Res Function(_$_StartDatePicked) then) =
      __$$_StartDatePickedCopyWithImpl<$Res>;
  $Res call({DateTime? startDate});
}

/// @nodoc
class __$$_StartDatePickedCopyWithImpl<$Res>
    extends _$AbsentFormEventCopyWithImpl<$Res>
    implements _$$_StartDatePickedCopyWith<$Res> {
  __$$_StartDatePickedCopyWithImpl(
      _$_StartDatePicked _value, $Res Function(_$_StartDatePicked) _then)
      : super(_value, (v) => _then(v as _$_StartDatePicked));

  @override
  _$_StartDatePicked get _value => super._value as _$_StartDatePicked;

  @override
  $Res call({
    Object? startDate = freezed,
  }) {
    return _then(_$_StartDatePicked(
      startDate == freezed
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc

class _$_StartDatePicked
    with DiagnosticableTreeMixin
    implements _StartDatePicked {
  const _$_StartDatePicked(this.startDate);

  @override
  final DateTime? startDate;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsentFormEvent.startDatePicked(startDate: $startDate)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsentFormEvent.startDatePicked'))
      ..add(DiagnosticsProperty('startDate', startDate));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StartDatePicked &&
            const DeepCollectionEquality().equals(other.startDate, startDate));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(startDate));

  @JsonKey(ignore: true)
  @override
  _$$_StartDatePickedCopyWith<_$_StartDatePicked> get copyWith =>
      __$$_StartDatePickedCopyWithImpl<_$_StartDatePicked>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAbsentFormList,
    required TResult Function(DateTime? startDate) startDatePicked,
    required TResult Function(DateTime? endDate) endDatePicked,
    required TResult Function(Reason reason) reasonChanged,
    required TResult Function(String noteChanged) noteChanged,
    required TResult Function() formSubmitted,
    required TResult Function() cancelled,
  }) {
    return startDatePicked(startDate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
  }) {
    return startDatePicked?.call(startDate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
    required TResult orElse(),
  }) {
    if (startDatePicked != null) {
      return startDatePicked(startDate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAbsentFormList value) getAbsentFormList,
    required TResult Function(_StartDatePicked value) startDatePicked,
    required TResult Function(_EndDatePicked value) endDatePicked,
    required TResult Function(_ReasonChanged value) reasonChanged,
    required TResult Function(_NoteChanged value) noteChanged,
    required TResult Function(_FormSubmitted value) formSubmitted,
    required TResult Function(_Cancelled value) cancelled,
  }) {
    return startDatePicked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
  }) {
    return startDatePicked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
    required TResult orElse(),
  }) {
    if (startDatePicked != null) {
      return startDatePicked(this);
    }
    return orElse();
  }
}

abstract class _StartDatePicked implements AbsentFormEvent {
  const factory _StartDatePicked(final DateTime? startDate) =
      _$_StartDatePicked;

  DateTime? get startDate => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_StartDatePickedCopyWith<_$_StartDatePicked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_EndDatePickedCopyWith<$Res> {
  factory _$$_EndDatePickedCopyWith(
          _$_EndDatePicked value, $Res Function(_$_EndDatePicked) then) =
      __$$_EndDatePickedCopyWithImpl<$Res>;
  $Res call({DateTime? endDate});
}

/// @nodoc
class __$$_EndDatePickedCopyWithImpl<$Res>
    extends _$AbsentFormEventCopyWithImpl<$Res>
    implements _$$_EndDatePickedCopyWith<$Res> {
  __$$_EndDatePickedCopyWithImpl(
      _$_EndDatePicked _value, $Res Function(_$_EndDatePicked) _then)
      : super(_value, (v) => _then(v as _$_EndDatePicked));

  @override
  _$_EndDatePicked get _value => super._value as _$_EndDatePicked;

  @override
  $Res call({
    Object? endDate = freezed,
  }) {
    return _then(_$_EndDatePicked(
      endDate == freezed
          ? _value.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc

class _$_EndDatePicked with DiagnosticableTreeMixin implements _EndDatePicked {
  const _$_EndDatePicked(this.endDate);

  @override
  final DateTime? endDate;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsentFormEvent.endDatePicked(endDate: $endDate)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsentFormEvent.endDatePicked'))
      ..add(DiagnosticsProperty('endDate', endDate));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EndDatePicked &&
            const DeepCollectionEquality().equals(other.endDate, endDate));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(endDate));

  @JsonKey(ignore: true)
  @override
  _$$_EndDatePickedCopyWith<_$_EndDatePicked> get copyWith =>
      __$$_EndDatePickedCopyWithImpl<_$_EndDatePicked>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAbsentFormList,
    required TResult Function(DateTime? startDate) startDatePicked,
    required TResult Function(DateTime? endDate) endDatePicked,
    required TResult Function(Reason reason) reasonChanged,
    required TResult Function(String noteChanged) noteChanged,
    required TResult Function() formSubmitted,
    required TResult Function() cancelled,
  }) {
    return endDatePicked(endDate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
  }) {
    return endDatePicked?.call(endDate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
    required TResult orElse(),
  }) {
    if (endDatePicked != null) {
      return endDatePicked(endDate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAbsentFormList value) getAbsentFormList,
    required TResult Function(_StartDatePicked value) startDatePicked,
    required TResult Function(_EndDatePicked value) endDatePicked,
    required TResult Function(_ReasonChanged value) reasonChanged,
    required TResult Function(_NoteChanged value) noteChanged,
    required TResult Function(_FormSubmitted value) formSubmitted,
    required TResult Function(_Cancelled value) cancelled,
  }) {
    return endDatePicked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
  }) {
    return endDatePicked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
    required TResult orElse(),
  }) {
    if (endDatePicked != null) {
      return endDatePicked(this);
    }
    return orElse();
  }
}

abstract class _EndDatePicked implements AbsentFormEvent {
  const factory _EndDatePicked(final DateTime? endDate) = _$_EndDatePicked;

  DateTime? get endDate => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_EndDatePickedCopyWith<_$_EndDatePicked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ReasonChangedCopyWith<$Res> {
  factory _$$_ReasonChangedCopyWith(
          _$_ReasonChanged value, $Res Function(_$_ReasonChanged) then) =
      __$$_ReasonChangedCopyWithImpl<$Res>;
  $Res call({Reason reason});

  $ReasonCopyWith<$Res> get reason;
}

/// @nodoc
class __$$_ReasonChangedCopyWithImpl<$Res>
    extends _$AbsentFormEventCopyWithImpl<$Res>
    implements _$$_ReasonChangedCopyWith<$Res> {
  __$$_ReasonChangedCopyWithImpl(
      _$_ReasonChanged _value, $Res Function(_$_ReasonChanged) _then)
      : super(_value, (v) => _then(v as _$_ReasonChanged));

  @override
  _$_ReasonChanged get _value => super._value as _$_ReasonChanged;

  @override
  $Res call({
    Object? reason = freezed,
  }) {
    return _then(_$_ReasonChanged(
      reason == freezed
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as Reason,
    ));
  }

  @override
  $ReasonCopyWith<$Res> get reason {
    return $ReasonCopyWith<$Res>(_value.reason, (value) {
      return _then(_value.copyWith(reason: value));
    });
  }
}

/// @nodoc

class _$_ReasonChanged with DiagnosticableTreeMixin implements _ReasonChanged {
  const _$_ReasonChanged(this.reason);

  @override
  final Reason reason;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsentFormEvent.reasonChanged(reason: $reason)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsentFormEvent.reasonChanged'))
      ..add(DiagnosticsProperty('reason', reason));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ReasonChanged &&
            const DeepCollectionEquality().equals(other.reason, reason));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(reason));

  @JsonKey(ignore: true)
  @override
  _$$_ReasonChangedCopyWith<_$_ReasonChanged> get copyWith =>
      __$$_ReasonChangedCopyWithImpl<_$_ReasonChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAbsentFormList,
    required TResult Function(DateTime? startDate) startDatePicked,
    required TResult Function(DateTime? endDate) endDatePicked,
    required TResult Function(Reason reason) reasonChanged,
    required TResult Function(String noteChanged) noteChanged,
    required TResult Function() formSubmitted,
    required TResult Function() cancelled,
  }) {
    return reasonChanged(reason);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
  }) {
    return reasonChanged?.call(reason);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
    required TResult orElse(),
  }) {
    if (reasonChanged != null) {
      return reasonChanged(reason);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAbsentFormList value) getAbsentFormList,
    required TResult Function(_StartDatePicked value) startDatePicked,
    required TResult Function(_EndDatePicked value) endDatePicked,
    required TResult Function(_ReasonChanged value) reasonChanged,
    required TResult Function(_NoteChanged value) noteChanged,
    required TResult Function(_FormSubmitted value) formSubmitted,
    required TResult Function(_Cancelled value) cancelled,
  }) {
    return reasonChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
  }) {
    return reasonChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
    required TResult orElse(),
  }) {
    if (reasonChanged != null) {
      return reasonChanged(this);
    }
    return orElse();
  }
}

abstract class _ReasonChanged implements AbsentFormEvent {
  const factory _ReasonChanged(final Reason reason) = _$_ReasonChanged;

  Reason get reason => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_ReasonChangedCopyWith<_$_ReasonChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_NoteChangedCopyWith<$Res> {
  factory _$$_NoteChangedCopyWith(
          _$_NoteChanged value, $Res Function(_$_NoteChanged) then) =
      __$$_NoteChangedCopyWithImpl<$Res>;
  $Res call({String noteChanged});
}

/// @nodoc
class __$$_NoteChangedCopyWithImpl<$Res>
    extends _$AbsentFormEventCopyWithImpl<$Res>
    implements _$$_NoteChangedCopyWith<$Res> {
  __$$_NoteChangedCopyWithImpl(
      _$_NoteChanged _value, $Res Function(_$_NoteChanged) _then)
      : super(_value, (v) => _then(v as _$_NoteChanged));

  @override
  _$_NoteChanged get _value => super._value as _$_NoteChanged;

  @override
  $Res call({
    Object? noteChanged = freezed,
  }) {
    return _then(_$_NoteChanged(
      noteChanged == freezed
          ? _value.noteChanged
          : noteChanged // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_NoteChanged with DiagnosticableTreeMixin implements _NoteChanged {
  const _$_NoteChanged(this.noteChanged);

  @override
  final String noteChanged;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsentFormEvent.noteChanged(noteChanged: $noteChanged)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsentFormEvent.noteChanged'))
      ..add(DiagnosticsProperty('noteChanged', noteChanged));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NoteChanged &&
            const DeepCollectionEquality()
                .equals(other.noteChanged, noteChanged));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(noteChanged));

  @JsonKey(ignore: true)
  @override
  _$$_NoteChangedCopyWith<_$_NoteChanged> get copyWith =>
      __$$_NoteChangedCopyWithImpl<_$_NoteChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAbsentFormList,
    required TResult Function(DateTime? startDate) startDatePicked,
    required TResult Function(DateTime? endDate) endDatePicked,
    required TResult Function(Reason reason) reasonChanged,
    required TResult Function(String noteChanged) noteChanged,
    required TResult Function() formSubmitted,
    required TResult Function() cancelled,
  }) {
    return noteChanged(this.noteChanged);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
  }) {
    return noteChanged?.call(this.noteChanged);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
    required TResult orElse(),
  }) {
    if (noteChanged != null) {
      return noteChanged(this.noteChanged);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAbsentFormList value) getAbsentFormList,
    required TResult Function(_StartDatePicked value) startDatePicked,
    required TResult Function(_EndDatePicked value) endDatePicked,
    required TResult Function(_ReasonChanged value) reasonChanged,
    required TResult Function(_NoteChanged value) noteChanged,
    required TResult Function(_FormSubmitted value) formSubmitted,
    required TResult Function(_Cancelled value) cancelled,
  }) {
    return noteChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
  }) {
    return noteChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
    required TResult orElse(),
  }) {
    if (noteChanged != null) {
      return noteChanged(this);
    }
    return orElse();
  }
}

abstract class _NoteChanged implements AbsentFormEvent {
  const factory _NoteChanged(final String noteChanged) = _$_NoteChanged;

  String get noteChanged => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_NoteChangedCopyWith<_$_NoteChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_FormSubmittedCopyWith<$Res> {
  factory _$$_FormSubmittedCopyWith(
          _$_FormSubmitted value, $Res Function(_$_FormSubmitted) then) =
      __$$_FormSubmittedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FormSubmittedCopyWithImpl<$Res>
    extends _$AbsentFormEventCopyWithImpl<$Res>
    implements _$$_FormSubmittedCopyWith<$Res> {
  __$$_FormSubmittedCopyWithImpl(
      _$_FormSubmitted _value, $Res Function(_$_FormSubmitted) _then)
      : super(_value, (v) => _then(v as _$_FormSubmitted));

  @override
  _$_FormSubmitted get _value => super._value as _$_FormSubmitted;
}

/// @nodoc

class _$_FormSubmitted with DiagnosticableTreeMixin implements _FormSubmitted {
  const _$_FormSubmitted();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsentFormEvent.formSubmitted()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'AbsentFormEvent.formSubmitted'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_FormSubmitted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAbsentFormList,
    required TResult Function(DateTime? startDate) startDatePicked,
    required TResult Function(DateTime? endDate) endDatePicked,
    required TResult Function(Reason reason) reasonChanged,
    required TResult Function(String noteChanged) noteChanged,
    required TResult Function() formSubmitted,
    required TResult Function() cancelled,
  }) {
    return formSubmitted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
  }) {
    return formSubmitted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
    required TResult orElse(),
  }) {
    if (formSubmitted != null) {
      return formSubmitted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAbsentFormList value) getAbsentFormList,
    required TResult Function(_StartDatePicked value) startDatePicked,
    required TResult Function(_EndDatePicked value) endDatePicked,
    required TResult Function(_ReasonChanged value) reasonChanged,
    required TResult Function(_NoteChanged value) noteChanged,
    required TResult Function(_FormSubmitted value) formSubmitted,
    required TResult Function(_Cancelled value) cancelled,
  }) {
    return formSubmitted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
  }) {
    return formSubmitted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
    required TResult orElse(),
  }) {
    if (formSubmitted != null) {
      return formSubmitted(this);
    }
    return orElse();
  }
}

abstract class _FormSubmitted implements AbsentFormEvent {
  const factory _FormSubmitted() = _$_FormSubmitted;
}

/// @nodoc
abstract class _$$_CancelledCopyWith<$Res> {
  factory _$$_CancelledCopyWith(
          _$_Cancelled value, $Res Function(_$_Cancelled) then) =
      __$$_CancelledCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CancelledCopyWithImpl<$Res>
    extends _$AbsentFormEventCopyWithImpl<$Res>
    implements _$$_CancelledCopyWith<$Res> {
  __$$_CancelledCopyWithImpl(
      _$_Cancelled _value, $Res Function(_$_Cancelled) _then)
      : super(_value, (v) => _then(v as _$_Cancelled));

  @override
  _$_Cancelled get _value => super._value as _$_Cancelled;
}

/// @nodoc

class _$_Cancelled with DiagnosticableTreeMixin implements _Cancelled {
  const _$_Cancelled();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsentFormEvent.cancelled()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'AbsentFormEvent.cancelled'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Cancelled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAbsentFormList,
    required TResult Function(DateTime? startDate) startDatePicked,
    required TResult Function(DateTime? endDate) endDatePicked,
    required TResult Function(Reason reason) reasonChanged,
    required TResult Function(String noteChanged) noteChanged,
    required TResult Function() formSubmitted,
    required TResult Function() cancelled,
  }) {
    return cancelled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
  }) {
    return cancelled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAbsentFormList,
    TResult Function(DateTime? startDate)? startDatePicked,
    TResult Function(DateTime? endDate)? endDatePicked,
    TResult Function(Reason reason)? reasonChanged,
    TResult Function(String noteChanged)? noteChanged,
    TResult Function()? formSubmitted,
    TResult Function()? cancelled,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAbsentFormList value) getAbsentFormList,
    required TResult Function(_StartDatePicked value) startDatePicked,
    required TResult Function(_EndDatePicked value) endDatePicked,
    required TResult Function(_ReasonChanged value) reasonChanged,
    required TResult Function(_NoteChanged value) noteChanged,
    required TResult Function(_FormSubmitted value) formSubmitted,
    required TResult Function(_Cancelled value) cancelled,
  }) {
    return cancelled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
  }) {
    return cancelled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAbsentFormList value)? getAbsentFormList,
    TResult Function(_StartDatePicked value)? startDatePicked,
    TResult Function(_EndDatePicked value)? endDatePicked,
    TResult Function(_ReasonChanged value)? reasonChanged,
    TResult Function(_NoteChanged value)? noteChanged,
    TResult Function(_FormSubmitted value)? formSubmitted,
    TResult Function(_Cancelled value)? cancelled,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled(this);
    }
    return orElse();
  }
}

abstract class _Cancelled implements AbsentFormEvent {
  const factory _Cancelled() = _$_Cancelled;
}

/// @nodoc
mixin _$AbsentFormState {
  AbsentForm get absentForm => throw _privateConstructorUsedError;
  Either<AbsentFailure, Unit>? get failureOrUnit =>
      throw _privateConstructorUsedError;
  Either<AbsentFailure, List<AbsentForm>>? get absentFailureOrAbsentFormList =>
      throw _privateConstructorUsedError;
  List<AbsentForm> get absentFormListAfterToday =>
      throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  bool get isSubmitting => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AbsentFormStateCopyWith<AbsentFormState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AbsentFormStateCopyWith<$Res> {
  factory $AbsentFormStateCopyWith(
          AbsentFormState value, $Res Function(AbsentFormState) then) =
      _$AbsentFormStateCopyWithImpl<$Res>;
  $Res call(
      {AbsentForm absentForm,
      Either<AbsentFailure, Unit>? failureOrUnit,
      Either<AbsentFailure, List<AbsentForm>>? absentFailureOrAbsentFormList,
      List<AbsentForm> absentFormListAfterToday,
      bool isLoading,
      bool isSubmitting});

  $AbsentFormCopyWith<$Res> get absentForm;
}

/// @nodoc
class _$AbsentFormStateCopyWithImpl<$Res>
    implements $AbsentFormStateCopyWith<$Res> {
  _$AbsentFormStateCopyWithImpl(this._value, this._then);

  final AbsentFormState _value;
  // ignore: unused_field
  final $Res Function(AbsentFormState) _then;

  @override
  $Res call({
    Object? absentForm = freezed,
    Object? failureOrUnit = freezed,
    Object? absentFailureOrAbsentFormList = freezed,
    Object? absentFormListAfterToday = freezed,
    Object? isLoading = freezed,
    Object? isSubmitting = freezed,
  }) {
    return _then(_value.copyWith(
      absentForm: absentForm == freezed
          ? _value.absentForm
          : absentForm // ignore: cast_nullable_to_non_nullable
              as AbsentForm,
      failureOrUnit: failureOrUnit == freezed
          ? _value.failureOrUnit
          : failureOrUnit // ignore: cast_nullable_to_non_nullable
              as Either<AbsentFailure, Unit>?,
      absentFailureOrAbsentFormList: absentFailureOrAbsentFormList == freezed
          ? _value.absentFailureOrAbsentFormList
          : absentFailureOrAbsentFormList // ignore: cast_nullable_to_non_nullable
              as Either<AbsentFailure, List<AbsentForm>>?,
      absentFormListAfterToday: absentFormListAfterToday == freezed
          ? _value.absentFormListAfterToday
          : absentFormListAfterToday // ignore: cast_nullable_to_non_nullable
              as List<AbsentForm>,
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isSubmitting: isSubmitting == freezed
          ? _value.isSubmitting
          : isSubmitting // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  $AbsentFormCopyWith<$Res> get absentForm {
    return $AbsentFormCopyWith<$Res>(_value.absentForm, (value) {
      return _then(_value.copyWith(absentForm: value));
    });
  }
}

/// @nodoc
abstract class _$$_AbsentFormStateCopyWith<$Res>
    implements $AbsentFormStateCopyWith<$Res> {
  factory _$$_AbsentFormStateCopyWith(
          _$_AbsentFormState value, $Res Function(_$_AbsentFormState) then) =
      __$$_AbsentFormStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {AbsentForm absentForm,
      Either<AbsentFailure, Unit>? failureOrUnit,
      Either<AbsentFailure, List<AbsentForm>>? absentFailureOrAbsentFormList,
      List<AbsentForm> absentFormListAfterToday,
      bool isLoading,
      bool isSubmitting});

  @override
  $AbsentFormCopyWith<$Res> get absentForm;
}

/// @nodoc
class __$$_AbsentFormStateCopyWithImpl<$Res>
    extends _$AbsentFormStateCopyWithImpl<$Res>
    implements _$$_AbsentFormStateCopyWith<$Res> {
  __$$_AbsentFormStateCopyWithImpl(
      _$_AbsentFormState _value, $Res Function(_$_AbsentFormState) _then)
      : super(_value, (v) => _then(v as _$_AbsentFormState));

  @override
  _$_AbsentFormState get _value => super._value as _$_AbsentFormState;

  @override
  $Res call({
    Object? absentForm = freezed,
    Object? failureOrUnit = freezed,
    Object? absentFailureOrAbsentFormList = freezed,
    Object? absentFormListAfterToday = freezed,
    Object? isLoading = freezed,
    Object? isSubmitting = freezed,
  }) {
    return _then(_$_AbsentFormState(
      absentForm: absentForm == freezed
          ? _value.absentForm
          : absentForm // ignore: cast_nullable_to_non_nullable
              as AbsentForm,
      failureOrUnit: failureOrUnit == freezed
          ? _value.failureOrUnit
          : failureOrUnit // ignore: cast_nullable_to_non_nullable
              as Either<AbsentFailure, Unit>?,
      absentFailureOrAbsentFormList: absentFailureOrAbsentFormList == freezed
          ? _value.absentFailureOrAbsentFormList
          : absentFailureOrAbsentFormList // ignore: cast_nullable_to_non_nullable
              as Either<AbsentFailure, List<AbsentForm>>?,
      absentFormListAfterToday: absentFormListAfterToday == freezed
          ? _value._absentFormListAfterToday
          : absentFormListAfterToday // ignore: cast_nullable_to_non_nullable
              as List<AbsentForm>,
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isSubmitting: isSubmitting == freezed
          ? _value.isSubmitting
          : isSubmitting // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_AbsentFormState
    with DiagnosticableTreeMixin
    implements _AbsentFormState {
  const _$_AbsentFormState(
      {required this.absentForm,
      required this.failureOrUnit,
      required this.absentFailureOrAbsentFormList,
      required final List<AbsentForm> absentFormListAfterToday,
      required this.isLoading,
      required this.isSubmitting})
      : _absentFormListAfterToday = absentFormListAfterToday;

  @override
  final AbsentForm absentForm;
  @override
  final Either<AbsentFailure, Unit>? failureOrUnit;
  @override
  final Either<AbsentFailure, List<AbsentForm>>? absentFailureOrAbsentFormList;
  final List<AbsentForm> _absentFormListAfterToday;
  @override
  List<AbsentForm> get absentFormListAfterToday {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_absentFormListAfterToday);
  }

  @override
  final bool isLoading;
  @override
  final bool isSubmitting;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsentFormState(absentForm: $absentForm, failureOrUnit: $failureOrUnit, absentFailureOrAbsentFormList: $absentFailureOrAbsentFormList, absentFormListAfterToday: $absentFormListAfterToday, isLoading: $isLoading, isSubmitting: $isSubmitting)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsentFormState'))
      ..add(DiagnosticsProperty('absentForm', absentForm))
      ..add(DiagnosticsProperty('failureOrUnit', failureOrUnit))
      ..add(DiagnosticsProperty(
          'absentFailureOrAbsentFormList', absentFailureOrAbsentFormList))
      ..add(DiagnosticsProperty(
          'absentFormListAfterToday', absentFormListAfterToday))
      ..add(DiagnosticsProperty('isLoading', isLoading))
      ..add(DiagnosticsProperty('isSubmitting', isSubmitting));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AbsentFormState &&
            const DeepCollectionEquality()
                .equals(other.absentForm, absentForm) &&
            const DeepCollectionEquality()
                .equals(other.failureOrUnit, failureOrUnit) &&
            const DeepCollectionEquality().equals(
                other.absentFailureOrAbsentFormList,
                absentFailureOrAbsentFormList) &&
            const DeepCollectionEquality().equals(
                other._absentFormListAfterToday, _absentFormListAfterToday) &&
            const DeepCollectionEquality().equals(other.isLoading, isLoading) &&
            const DeepCollectionEquality()
                .equals(other.isSubmitting, isSubmitting));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(absentForm),
      const DeepCollectionEquality().hash(failureOrUnit),
      const DeepCollectionEquality().hash(absentFailureOrAbsentFormList),
      const DeepCollectionEquality().hash(_absentFormListAfterToday),
      const DeepCollectionEquality().hash(isLoading),
      const DeepCollectionEquality().hash(isSubmitting));

  @JsonKey(ignore: true)
  @override
  _$$_AbsentFormStateCopyWith<_$_AbsentFormState> get copyWith =>
      __$$_AbsentFormStateCopyWithImpl<_$_AbsentFormState>(this, _$identity);
}

abstract class _AbsentFormState implements AbsentFormState {
  const factory _AbsentFormState(
      {required final AbsentForm absentForm,
      required final Either<AbsentFailure, Unit>? failureOrUnit,
      required final Either<AbsentFailure, List<AbsentForm>>?
          absentFailureOrAbsentFormList,
      required final List<AbsentForm> absentFormListAfterToday,
      required final bool isLoading,
      required final bool isSubmitting}) = _$_AbsentFormState;

  @override
  AbsentForm get absentForm => throw _privateConstructorUsedError;
  @override
  Either<AbsentFailure, Unit>? get failureOrUnit =>
      throw _privateConstructorUsedError;
  @override
  Either<AbsentFailure, List<AbsentForm>>? get absentFailureOrAbsentFormList =>
      throw _privateConstructorUsedError;
  @override
  List<AbsentForm> get absentFormListAfterToday =>
      throw _privateConstructorUsedError;
  @override
  bool get isLoading => throw _privateConstructorUsedError;
  @override
  bool get isSubmitting => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_AbsentFormStateCopyWith<_$_AbsentFormState> get copyWith =>
      throw _privateConstructorUsedError;
}
